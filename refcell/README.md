## 内部可变性（interior mutability）

- 内部可变性是 Rust 的设计模式之一
- 它允许你在只持有不可变引用的前提下对数据进行修改
  - 数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则
  - RefCell\<T>类型遵循内部可变性模式

## RefCell\<T>

- 与 Rc\<T>不同，RefCell\<T>类型代表了其持有数据的唯一所有权

## 借用规则

- 在任意给定时间，只能拥有一个可变引用或任意数量的不可变引用之一（而不是全部）
- 引用必须总是有效的

## RefCell\<T>与 Box\<T>的区别

| Box\<T>                    | RefCell\<T>              |
| -------------------------- | ------------------------ |
| 编译时强制代码遵守借用规则 | 只会在运行时检查借用规则 |
| 否则出现错误               | 否则出现 panic           |

## 借用规则在不同阶段进行检查的比较

| 编译阶段               | 运行时                                               |
| ---------------------- | ---------------------------------------------------- |
| 尽早暴露问题           | 问题暴露延后，甚至到生产环境                         |
| 没有任何运行时开销     | 因借用计数产生些许性能损失                           |
| 对大多数场景是最佳选择 | 实现某些特定的内存安全场景(不可变环境中修改自身数据) |
| 是 Rust 的默认行为     |

## RefCell\<T>

- 与 Rc\<T>相似，只能用于单线程的场景

## 选择 Box\<T>, Rc\<T>,RefCell\<T>的依据

|                  | Box\<T>                        | Rc\<T>                   | RefCell\<T>                    |
| ---------------- | ------------------------------ | ------------------------ | ------------------------------ |
| 同一数据的所有者 | 一个                           | 多个                     | 一个                           |
| 可变性，借用检查 | 可变，不可变借用（编译时检查） | 不可变借用（编译时检查） | 可变，不可变借用（运行时检查） |
- 其中：即便RefCell\<T>本身不可变，但仍能修改其中存储的值

## 内部可变性：不可变值得可变借用
