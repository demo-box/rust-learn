## 生命周期

- Rust 的每个引用都有自己的生命周期
- 生命周期：引用保持有效的作用域
- 大多数情况: 生命周期是隐式的，可被推断的
- 当引用的生命周期可能以不同的方式相互关联时：手动标注生命周期

## 生命周期 - 避免悬垂引用（dangling reference）

- 生命周期的主要目标: 避免悬垂引用(dangling reference)

## 借用检查器

- Rust 编译器的借用检查器: 比较作用域来判断所有的借用是否合法

## 生命周期标注语法

- 生命周期的标注不会改变引用的生命周期长度
- 当指定来泛型生命周期参数，函数可以接受带有任何生命周期的引用
- 生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期

## 生命周期标注 - 语法

- 生命周期参数名:

  - 以'开头
  - 通常全小写且非常短
  - 很多人使用'a

- 生命周期标注的位置:
  - 在引用的&符号后
  - 使用空格将标注和引用类型分开

## 生命周期标注 - 例子

- &i32 // 一个引用
- &'a i32 // 带有显示生命周期的引用
- &'a mut i32 // 带有显示生命周期的可变引用
- 单个生命周期标注本身没有意义

## struct 定义中的生命周期标注

- Struct 里可包括:
  - 自持有的类型
  - 引用: 需要的每个引用上添加生命周期标注

## 生命周期的省略

- 我们知道:

  - 每个引用都有生命周期
  - 需要为使用引用的函数或 struct 指定生命周期参数

- 在 Rust 引用分析中所编入的模式称为生命周期省略规则

  - 这些规则无需开发者来遵守
  - 它们是一些特殊情况，由编译器来考虑
  - 如果你的代码符号这些情况，那么就无需显示标注生命周期

- 生命周期省略规则不会提供完整的推断
  - 如果应用规则后，引用的生命周期仍然模糊不清，编译会报错
  - 解决方法: 手动添加生命周期标注,表明引用间的相互关系

## 输入，输出生命周期

- 生命周期在:
  - 函数/方法的参数: 输入生命周期
  - 函数/方法的返回值: 输出生命周期

## 生命周期省略的三个规则

- 编译器使用 3 个规则在没有显示标注生命周期的情况下，来确定引用的生命周期

  - 规则 1 应用于输入生命周期
  - 规则 2，3 应用于输出生命周期
  - 如果编译器应用完 3 个规则之后，仍然有无法确定生命周期的引用， 则编译报错
  - 这些规则适用于 fn 定义和 impl 块

- 规则 1：每个引用类型的参数都有自己的生命周期
- 规则 2：如果只有 1 个输入生命周期参数，那么该生命周期被赋给所有的输出生命周期参数
- 规则 3：如果有多个输入生命周期参数，但其中一个是&self 或&mut self，那么 self 的生命周期会被赋给所有的输出生命周期参数

## 生命周期省略的三个规则 - 例子

- 假设我们是编译器
- fn first_word(s: &str) -> &str {}
- 应用规则 1 之后
- fn first_word<'a>(s: &'a str) -> &str {}
- 应用规则 2 之后
- fn first_work<'a>(s: &'a str) -> &'a str {}
- 确定了所有输入输出生命周期，所以编译通过

- 假设我们是编译器
- fn longest(x: &str, y: &str) -> &str {}
- 应用规则 1 之后
- fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {}
- 无法应用规则 2 和 3
- 依旧无法确定输出生命周期，所以编译报错

## 方法定义中的生命周期标注

- 在 struct 上使用生命周期实现方法，语法和泛型参数的语法一样
- 在哪声明和使用生命周期参数，依赖于:
  - 生命周期参数是否和字段，方法的参数或返回值有关
- struct 字段的生命周期名:
  - 在 impl 后声明
  - 在 struct 名后使用
  - 这些生命周期是 struct 类型的一部分
- impl 块内的方法签名中
  - 引用必须绑定于 struct 字段引用的生命周期，或者引用是独立的也可以
  - 生命周期省略规则经常使得方法中的生命周期标注不是必须的

## 静态生命周期

- 'static 是一个特殊的生命周期: 整个程序的持续时间
  - 例如: 所有的字符串字面值都拥有'static 生命周期
    - let s: &'static str = "I have a static lifetime.";
- 为引用指定 'static 生命周期前要三思:
  - 是否需要引用在程序整个生命周期内都存活
