## 相关的概念

- 指针: 一个变量在内存中包含的是一个地址(指向其它数据)
- rust 中最常见的指针是‘引用’
- 引用:
  - 使用 &
  - 借用它指向的值
  - 没有其余开销
  - 最常见的指针类型

## 智能指针

- 智能指针是这样一些数据结构
  - 行为和指针相似
  - 有额外的元数据和功能

## 引用计数(reference counting)智能指针类型

- 通过记录所有者的数量，使一份数据被多个所有者同时持有
- 并在没有任何所有者时自动清理数据

## 引用和智能指针的其它不同

- 引用: 只借用数据
- 智能指针: 很多时候都拥有它所指向的数据

## 智能指针的例子

- String 和 Vec<T>

- 都拥有一片内存区域，且允许用户对其操作

- 还拥有元数据(例如容量等)

- 提供额外的功能或保障(String 保障其数据是合法的 UTF-8 编码)

## 智能指针的实现

- 智能指针通常使用 struct 实现，并且实现了:

  - Deref 和 Drop 这两个 trait

- Deref trait: 允许智能指针 struct 的实例像引用一样使用
- Drop trait： 允许你自定义当智能指针实例走出作用域时的代码

## Box<T>

- Box<T>是最简单的智能指针

  - 允许你在 heap 上存储数据(而不是 stack)
  - stack 上是指向 heap 数据的指针
  - 没有性能开销
  - 没有其它额外功能

  - 实现了 Deref trait 和 Drop trait

## Box<T>的常用场景

- 在编译时，某类型的大小无法确定. 但使用该类型时，上下文却需要知道它的确切大小。
- 当你有大量数据，想移交所有权，但需要确保在操作时数据不会被复制
- 使用某个值时，你只关心它是否实现了特定的 trait， 而不关心它的具体类型

## 使用 Box 赋能递归类型

- 在编译时，Rust 需要知道一个类型所占的空间大小
- 而递归类型的大小无法在编译时确定
- 但 Box 类型的大小确定
- 在递归类型中使用 Box 就可以解决上述问题

## 关于 Cons List

- Cons List 是来自 Lisp 语言的一种数据结构
- Cons List 里每个成员由两个元素组成

  - 当前项的值
  - 下一个元素

- Cons List 里最后一个成员只包含一个 Nil 值，没有下一个元素

![EZTXL____8F6_YFMY_25RR3.png](https://i.loli.net/2021/10/17/vnFLTwYEizalBVR.png)

## Cons List 并不是 Rust 的常用集合

- 通常情况下, Vec<T>是更好的选择

## 使用 Box 来获得确定大小的递归类型

- Box<T>是一个指针，Rust 知道它需要多少空间，因为:
  - 指针的大小不会基于它指向的数据的大小变化而变化

## 定义自己的智能指针

TODO:
https://www.bilibili.com/video/BV1hp4y1k7SV?p=87&spm_id_from=pageDriver
